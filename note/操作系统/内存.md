# 内存

---

## 概述

### 什么是内存

- 内存是用于存放数据的硬件。程序执行前**需要先放到内存中才能被CPU处理**
- 在多道程序环境下，系统中会有多个程序并发运行，就会有多个程序的数据需要同时放到内存中，为了区分各个程序的数据是放在什么地方的，就需要**对内存的存储单元编地址**
  - **地址从0开始，每个地址对应一个存储单元**
  - **存储单元**
    - 如果计算机**按字节编址**，则**每个存储单元大小为 1 字节**，即 1Byte，即 8 个二进制位
    - 如果**字长为 16位(也可能位32位、64位，需按具体情况判断)**的计算机**按字编址**，则**每个存储单元大小为 1 个字**，即 2Byte，即 16 个二进制位

### 进程运行的基本原理

- **指令的工作原理**
  - 操作码 + 若干参数(可能包含地址参数)
- **逻辑地址与物理地址**
- **代码 -> 程序运行**
  - 编辑源代码文件(程序员)
  - 编译 - 由源代码文件生成目标模块(高级语言翻译为机器语言)
  - 链接 - 由目标模块生成装入模块，链接后形成完成的逻辑地址
  - 装入 - 将装入模块装入内存，装入后形成物理地址
- **链接方式**
  - 静态链接 - 装入前链接为一个完成的装入模块
  - 装入时动态链接 - 运行前边装入边链接
  - 运行时动态链接 - 运行时需要目标模块才装入并链接
- **装入方式**
  - 绝对装入 - 编译时产生绝对地址
  - 可重定位装入 - 装入时将逻辑地址转换为物理地址
  - 动态运行时装入 - 运行时将逻辑地址转换为物理地址，需要设置重定位寄存器

## 内存管理

- **内存空间的分配与回收**
- **内存空间的扩充**(实现虚拟性)
- **地址转换**
  - 操作系统负责实现逻辑地址到物理地址的转换
  - 实现方式
    - **绝对装入**：编译器负责地址转换(单道程序阶段，无操作系统)
    - **可重定位装入**：装入程序负责地址转换(早期多道批处理系统)
    - **动态运行时装入**：运行时才进行地址转换(现代操作系统)
- **存储保护**
  - 保证各进程在自己的内存空间运行，不会越界访问
  - 实现方式
    - **设置上下限寄存器**
    - **利用重定位寄存器、界地址寄存器进行判断**

## 覆盖与交换

### 覆盖技术

- **核心思想**
  - **将程序分为多个段(多个模块)，常用的段常驻内存，不常用的段在需要时调入内存**
  - 内存中分为**一个固定区和若干个覆盖区**
  - 需要常驻内存的段放在**固定区**中，**调入后不再调出**(除非运行结束)
  - 不常用的段放在**覆盖区**，**需要用到时调入内存，用不到是调出内存**
- **缺点**
  - 必须由程序员生命覆盖结构，操作系统自动完成覆盖 - **对用户不透明，增加了用户编程负担**

### 交换技术

- **核心思想**
  - **内存空间紧张时，系统将内存中某些进程暂时换出外存，将外存中某些已具备运行条件的进程换入内存**(进程在内存与磁盘间动态调度)
- **在外存(磁盘)的什么位置保存被换出的进程**
  - 具有对换功能的操作系统中，通常把磁盘空间分为**文件区**与**对换区**两部分
  - **文件区**主要用于存放文件，**主要追求存储空间的利用率**，因此对文件区空间的管理**采用离散分配方式**
  - **对换区**空间只占磁盘空间的很小部分，**被换出的进程数据就存放在对换区**。由于对换的速度直接影响到操作系统的整体速度，因此对换区空间的管理**主要追求换入换出速度**，因此通常对换区采用**连续分配方式**
  - 即**对换区的I/O速度比文件区的更快**
- **什么时候交换**
  - **交换通常在许多进程运行且内存吃紧时发生，而系统负荷降低就暂停**
  - 例如在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出
- **换出哪些进程**
  - 可优先换出阻塞进程
  - 可优先换出优先级低的进程
  - 为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存中的驻留时间
- **注意：PCB会常驻内存，不会被换出**

### 覆盖与交换

- **区别**
  - 覆盖是在同一个程序或进程中的
  - 交换是在不同进程(或作业)之间的

## 连续分配管理方式

- **连续分配**：指为用户进程分配的必须是一个**连续的内存空间**

### 单一连续分配

- 内存被分为**系统区**和**用户区**。**系统区**用于存放操作系统相关数据；**用户区**用于存放用户相关数据。**内存中只能有一道用户程序**，用户程序独占整个用户区空间
- **无外部碎片，有内部碎片**；**存储器利用率极低**

### 固定分区分配

- 支持多道程序，内存**用户空间分为若干个固定大小的分区，每个分区只能装一道作业**
- **无外部碎片，有内部碎片**
- 分区方式
  - 分区大小相等
  - 分区大小不等

### 动态分区分配

- 支持多道程序，**在进程装入内存时，根据进程的大小动态地建立分区**
- **无内部碎片，有外部碎片**
- **外部碎片可用"紧凑"技术来解决**
- 回收内存分区时，可能遇到四种情况
  - 回收区之后有相邻的空闲分区
  - 回收区之前有相邻的空闲分区
  - 回收区前、后都有相邻的空闲分区
  - 回收区前、后都没有相邻的空闲分区

## 动态分区分配算法

**在动态分区分配方式中，当很多空闲分区都能满足需求时，应该选择哪个分区进行分配**

### 首次适应算法 - First Fit

- **算法思想**
  - **每次都从低地址开始查找，找到第一个能满足大小的空闲分区**
- **实现方案**
  - **空闲分区以地址递增的次序排列**，每次分配内存时顺序查找**空闲分区链(或空闲分区表)**，找到大小能满足要求的第一个空闲分区
- **缺点**
  - 每次都从链头开始查找，这可能会导致低地址部分出现很多小的空闲分区，而**每次分配查找时，都要经过这些分区，因此也增加了查找的开销**

### 最佳适应算法 - Best Fit

- **算法思想**
  - **为保证当"大进程"到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即优先使用更小的空闲区**
- **实现方案**
  - **空闲分区按容量递增次序链接**，每次分配内存时顺序查找**空闲分区链(或空闲分区表)**，找到大小能满足要求的第一个空闲分区
- **缺点**
  - 每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块
  - 这种方法**会产生很多的外部碎片**

### 最坏使用算法 - Worst Fit

- **算法思想**
  - 为了解决最佳适应算法的问题 - 留下太多难以利用的小碎片，可以**在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用**
- **实现方案**
  - **空闲分区按容量递减次序链接**，每次分配内存时顺序查找**空闲分区链(或空闲分区表)**，找到大小能满足要求的第一个空闲分区
- **缺点**
  - 每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但这种方式会导致较大的连续空闲区被迅速用完。如果之后有**大进程**到达，就没有内存分区可用了

### 邻近适应算法 - Next Fit

- **算法思想**
  - 首次适应算法每次都从链头开始查找，导致低地址部分出现很多小的空闲分区，而每次分配查找时都需要经过这些分区，增加了查找的开销。如果每次都从上一次查找结束的位置开始检索，就能解决上述问题
- **实现方案**
  - 空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时**从上一次查找结束的位置开始查找空闲分区表(或空闲分区链)**，找到大小能满足要求的第一个空闲分区
- **缺点**
  - 邻近适应算法的规则**可能会导致低地址、高地址部分的空闲分区都有相同的概率被使用**，也就**导致了高地址部分的大分区更可能被使用，被划分为小分区，最后导致没有大分区可用**(最大适应算法的缺点)

## 基本分页存储管理

- **基本思想**
  - 将进程分页，各个页面可离散地放到各个内存块中
- **地址转换**
  - 计算出逻辑地址对应的页号
  - 找到对应页面在内存中的存放位置
  - 计算逻辑地址对应的页内偏移量
  - **物理地址 = 页面起始地址 + 页内偏移量**
- **页号、页内偏移量**
  - 页号 = 逻辑地址 / 页面大小
  - 页内偏移量 = 逻辑地址 % 页面大小
  - 或根据逻辑地址结构计算 ->  逻辑地址 = [页号P，页内偏移量W]
- **页表**
  - 页表记录进程页面和实际存放的内存块之间的映射关系
  - 一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由**页号**和**块号**组成
  - 每个页表项的**长度是相同的，页号是隐含的**

## 基本地址变换机构

### 页表寄存器

- **基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址**
- 通常会在系统中设置一个**页表寄存器(PTR)**，存放**页表在内存中的起始地址F 和 页表长度M**
- 进程未执行，页表的起始地址和页表长度**放在进程控制块(PCB)**中，当进程被调度时，操作系统内核会把它们放到页表寄存器中

### 地址变换

- 根据逻辑地址计算出页号、页内偏移量
- 页号的合法性检查(与页表长度对比)
- 若页号合法，再根据页表其实地址、页号找到对应页表项 - 第一次访问：查页表
- 根据页表项中记录的内存块号、页内偏移量得到最终的物理地址
- 访问物理内存对应的内存单元 - 第二次访问：查内存

### 细节

- **页内偏移量位数 与 页面大小的关系**
- **页式管理中地址是一维的**
- 实际应用中，通常使一个页框恰好能放入整数个页表项
- 为了方便找到页表项，页表一般是放在连续的内存块中的

## 带快表的地址变换机构

### 局部性原理

-  **时间局部性**
  - 如果执行了程序中的某条指令，那么不久后这条指令很有可能被再次执行；如果某个数据被访问过，不久后该数据很可能被再次访问
- **空间局部性**
  - 一旦程序访问了某个存储单元，在不久后，其附近的存储单元也很有可能被再次访问(因为很多数据在内存中都是连续存放的)

### 快表

- **快表**：又称为**相联寄存器(TLB)**，是一种**访问速度比内存快很多的高速缓冲存储器**，用来存放当前访问的若干项，以加速地址变换的过程。与此对应，内存中的页表常称为**慢表**

### 地址变换

- CPU给出逻辑地址，由某个硬件计算得到页号、页内偏移量，将页号与快表中的页号进行比较
- 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元
- 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，并将该页表项存入快表，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元
- **若快表命中，则访问某个逻辑地址仅需一次访存即可**
- **若快表未命中，则访问某个逻辑地址需要两次访存**
- **由于查询快表的速度比查询内存中页表的速度快很多，因此只要命中快表，可节省很多时间**

## 两级页表

### 单级页表

- **问题**
  - **由于页表必须连续存放，如果页表项很多，页表很大，会占用很多个连续的页框**
  - 由局部性原理可知，很多时候，**进程在一段时间内只需要访问某几个页面就可以正常工作了**，因此，没有必要让整个页表都常驻内存

### 两级页表

- 将过长的页表再分页
- **逻辑地址结构**：[一级页号，二级页号，页内偏移量]

### 地址变换

- 按照地址结构将逻辑地址拆分为三部分
- 从PCB中读出页目录表起始地址，根据一级页号查询页目录表，找到下一级页表在内存中的存放位置
- 根据二级页号查表，找到最终想要访问的内存块号
- 结合页内偏移量得到物理地址

### 细节

- **多级页表中，各级页表的大小不能超过一个页面，若两级页表不够，可以分更多级**
- **多级页表的访存次数(假设没有快表机构) - N级页表访问一个逻辑地址需要N+1次访存**

## 基本分段式存储管理

### 分段

- 将地址空间按照自身的逻辑关系划分为若干个段，每段从0开始编址
- 每个段在内存中占连续内存空间，但各段之间可以不相连
- 逻辑地址结构：[段号，段内地址]

### 段表

- 记录逻辑地址到实际存储地址的映射关系
- 每个段对应一个段表项。各段表项长度相同，由段号(隐含)、段长、基址组成

### 地址变换

- 由逻辑地址得到段号、段内地址
- 段号与段表寄存器中的段长度比较，检查是否越界
- 由段表起始地址、段号找到对应段表项
- **根据段表项中记录的段长，检查段内地址是否越界**
- 由段表中的**基址 + 段内地址**得到最终的物理地址
- 访问目标单元

### 分段与分页

- **分页对用户不可见，分段对用户可见**
- **分页的地址空间是一维的，分段的地址空间是二维的**
- **分段更容易实现信息的保护与共享(纯代码 / 可重入代码可以共享)**
- **分页(单级页表)、分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机构**

## 段页式管理

### 分页、分段分析

- **分页**
  - 优点：内存空间利用率高，**不会产生外部碎皮那**，只会有少量的内部碎片
  - 缺点：不方便按照逻辑模块实现信息的共享和保护
- **分段**
  - 优点：方便按照逻辑模块实现信息的共享和保护
  - 缺点：如果段长过长，为其分配很大的连续内存空间会很不方便。另外，段式存储会产生**外部碎片**

### 段表、页表

- 每个段对应一个段表项，各段表项长度相同，由**段号(隐藏)、页表长度、页表存放地址**组成
- 每个页对应一个页表项，各页表项长度相同，由**页号(隐藏)、页面存放地址**组成

### 地址变换

- 由逻辑地址得到段号、页号、页内偏移量
- 段号与段表寄存器中的段长度比较，检查是否越界
- 由段表地址、段号找到对应段表项
- 根据段表中记录的页表长度，检查页号是否越界
- 由段表中的页表地址、页号找到页表，找到相应页表项
- 由页表存放的内存块号、页内偏移量得到最终的物理地址
- 访问目标单元

### 访存次数

- 第一次 - 查段表、第二次 - 查页表、第三次 - 访问目标单元
- 可引入快表机构，以段号和页号为关键字查询快表，即可直接找到最终的目标页面位置。引入快表后仅需一次访存

## 虚拟内存

### 传统存储管理

- **一次性**
  - 作业数据必须一次全部调入内存
- **驻留性**
  - 作业数据在整个运行期间都会常驻内存

### 高速缓存技术

- 根据局部性原理，可以将使用频繁的数据放到更高速的存储器中

### 虚拟内存的定义和特征

- 程序不需要全部装入即可运行，运行时根据需要动态地调入数据，若内存不够，还需换出一些数据
- 特征
  - **多次性**：无需在作业运行时一次性全部装入内存，而是被允许分成多次调入内存
  - **对换性**：无需在作业运行时一直常驻内存，而是允许在作业运行过程中，将作业换入、换出
  - **虚拟性**：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量

### 虚拟技术的实现

- 访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存(请求调页功能)
- 内存空间不够时，将内存中暂时用不到的信息换出到外存(页面置换功能)
- 虚拟内存的实现
  - 请求分页存储管理
  - 请求分段存储管理
  - 请求段页式存储管理

## 请求分页管理

### 页表机制

- 与基本分页管理相比，请求分页管理中，为了实现**请求分页**，操作系统需要知道每个页面是否已经调入内存；如果还没有调入，也需要知道该页面在外存中存放的位置
- **页表项**
  - **状态位**：表示页面是否已在内存中
  - **访问字段**：记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考
  - **修改位**：表示页面调入内存后是否被修改过，**只有修改过的页面才需要在置换时写回外存**
  - **外存地址**：页面在外存中存放的位置

### 缺页中断机构

- 找到状态页表项后检查页面是否已在内存，若没在内存，产生缺页中断
- 缺页中断处理中，需要将目标页面调入内存，有必要时还要换出页面
- 缺页中断属于**内中断**，属于内中断中的**故障**，即可能被系统修复的异常
- 一条指令在执行过程中可能产生多次缺页中断

### 地址变换机构

- 找到页表项时需要检查页面是否在内存中
- 若页面不在内存中，则需要请求调页
- 若内存空间不够，还需要换出页面
- 页面调入内存后，需要修改相应页表项

## 页面置换算法

**页面的换入、换出需要磁盘I/O，会有较大的开销，因此，好的页面置换算法应该追求更少的缺页率**

### 最佳置换算法 - OPT

- **算法思想**
  - 每次选择**淘汰的页面将是以后永不使用，或在最长时间内不会再被访问的页面**，这样可以保证最少的缺页率
- **特点**
  - **最佳置换算法保证最低的缺页率**
  - 实际上，只有在进程执行过程中才能知道接下来会访问到的是哪个页面，操作系统无法提前预判页面的访问序列，因此，**最佳置换算法是无法实现的**

### 先进先出置换算法 - FIFO

- **算法思想**
  - 每次选择**淘汰的页面是最早进入内存的页面**
- **实现方法**
  - 把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时，选择队头的页面换出即可。队列的最大长度取决于系统为进程分配了多少个内存块
- **Belady异常**
  - 当为进程分配的物理块数增大时，缺页次数不减反增的异常现象
- **特点**
  - **实现简单**
  - **会产生Belady异常**，该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问
  - **算法性能差**

### 最近最久未使用置换算法 - LRU

- **算法思想**
  - 每次**淘汰的页面都是最近最久未使用的页面**
- **实现方法**
  - 赋予每个页面对应的页表项中，**用访问字段记录该页面自上次被访问以来所经历的时间 t**，当需要淘汰一个页面时，选择现有页面中 t 值最大的，即**最近最久未使用的页面**
- **特点**
  - **算法性能好**
  - 算法的实现需要专门的硬件支持，**实现困难，开销大**

### 时钟置换算法 - CLOCK

- **算法思想**
  - 一种**性能与开销均衡的算法**，又称为**CLOCK算法、最近未用算法(NRU，Not Recently Used)**
- **实现方法**
  - **为每个页面设置一个访问位，访问位为1表示最近被访问过，访问位为0表示最近没有被访问过**
  - **将内存中的页面都通过链接指针连接成一个循环队列**
- **简单Clock算法**
  - **实现方案**
    - 为每个页面设置一个访问位，访问位为1表示最近被访问过，访问位为0表示最近没有被访问过
    - 将内存中的页面都通过链接指针连接成一个循环队列
    - 当需要淘汰一个页面时，检查页的访问位，
    - **访问位为0 ，选择该页换出**
    - **访问位为0 ，将它置为 0 ，暂不换出，继续检查下一个页面**
    - 若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描
    - **第二轮扫描中一定会有访问位为 0 的页面，因此简单的Clock算法选择一个淘汰页面最多需要两轮扫描**
  - **特点**
    - **实现简单，算法开销小**
    - **未考虑页面是否被修改过**
- **改进型Clock算法**
  - **改进思想**
    - 简单Clock算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。**只有被淘汰的页面被修改过时，才需要写回外存**
    - **在其他条件相同时，应优先淘汰没有修改过的页面 - 避免I/O操作**
  - **改进方案**
    - 在简单Clock算法实现的基础上，增设一个**修改位**
    - **修改位为0 -> 表示页面没有被修改过**
    - **修改位为1 -> 表示页面被修改过**
    - (访问位，修改位)表示各页面的状态
  - **实现方案**
    - 第一轮：从当前位置开始扫描到第一个(0，0)的页用于替换，本轮扫描不修改任何标志位
      - **第一优先级：最近没访问且没被修改的页面**
    - 第二轮：若第一轮扫描失败，则重新扫描，查找第一个(0，1)的页用于替换，本轮将所有扫描过的页的访问位设为0
      - **第二优先级：最近没有被访问，但被修改的页面**
    - 第三轮：若第二轮扫描失败，则重新扫描，查找第一个(0，0)的页用于替换，本轮扫描不修改任何标志位 
      - **第三优先级：最近被访问，没有被修改的页面**
    - 第四轮：若第三轮扫描失败，则重新扫描，查找第一个(0，1)的页用于替换
      - **第四优先级：最近被访问且被修改的页面** 
    - **由于第二轮中已将所有页的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个页被选中，因此，改进型Clock算法选择一个淘汰页面最多会进行四轮扫描**
  - **特点**
    - **性能好，算法开销小**

## 页面分配策略

### 驻留集

- 指请求分页存储管理中给进程分配的内存块的集合
- **若驻留集太小，会导致缺页频繁，系统花大量的时间处理缺页，实际用于进程推进的时间很少**
- **若驻留集太大，会导致多道程序并发度下降，资源利用率低**

### 页面分配

- **固定分配**
  - 操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变 - **驻留集大小不变**
- **可变分配**
  - 先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少 - **驻留集大小可变**

### 置换策略

- **局部置换**
  - 发生缺页时**只能选择进程自己的物理块进行置换**
- **全局置换**
  - 可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程

### 分配 - 置换策略

- **固定分配 - 局部置换**
  - 进程运行前就分配一定数量的物理块，缺页时只能换出进程自己的某一页
- **可变分配 - 全局置换**
  - 只要缺页就分配新的物理块，可能来自空闲物理块，也可能需要换出别的进程页面
- **可变分配 - 局部置换**
  - 频繁缺页的进程，多分配一些物理块；缺页率很低的进程，回收一些物理块，直到缺页率合适

### 何时调入页面

- **预调入策略**
  - 根据局部性原理，**一次调入若干个相邻的页面到内存中**
  - **主要用于进程的首次调入**
- **请求调入策略**
  - **进程在运行期间发生缺页时才将所缺页面调入内存**
  - 由这种调入策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要进行磁盘I/O操作，因此I/O开销较大

### 从何处调入页面

- **对换区**：采用连续存储方式，容量小，速度快
- **连续区**：采用离散存储方式，容量大，速度慢
- **调入**
  - **对换区足够大**
    - 运行时将数据从文件区复制到对换区，之后所有的页面调入、调出都是在内存与对换区之间进行
  - **对换区不够大**
    - **不会修改的数据**每次从文件区调入
    - **会修改的数据**调出到对换区，需要时再从对换区调入
  - **UNIX方式**
    - 第一次使用的页面都从文件区调入
    - 会修改的数据调出到对换区，需要时再从对换区调入

### 抖动/颠簸现象

- **概念**
  - 页面频繁换入换出的现象
- **主要原因**
  - 分配给进程的物理块不够

### 工作集

- 在某段时间间隔里，进程实际访问页面的集合
- 驻留集大小一般不能小于工作集大小
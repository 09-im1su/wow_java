# 进程

---

## 进程概述

### 定义

- 进程是进程实体的运行过程，是系统进行资源分配和系统调度的一个独立单位

### 组成

- **PCB**
  - 进程描述信息
  - 进程控制和管理信息
  - 资源分配清单
  - 处理机相关信息
- **程序段**
  - 存放要执行的代码
- **数据段**
  - 存放程序运行过程中处理的各种数据

### 组织形式

- **链接形式**
  - 按进程状态将PCB分为多个队列，使用链表连接
- **索引方式**
  - 按进程状态建立几张索引表，各表项指向一个PCB

### 特征

- **动态性**
  - 进程的最基本特征
- **并发性**
- **独立性**
  - 进程是系统进行资源分配、调度的独立单位
- **异步性**
  - 各进程以不可预知的速度向前推进，可能导致运行结果的不确定性
- **结构性**

## 进程状态

### 状态

- **运行状态**	CPU OK - 其他资源 OK
- **就绪状态**	CPU NO - 其他资源 OK
- **阻塞状态**	CPU NO - 其他资源 NO
- **创建状态**
  - 操作系统为新进程分配资源、创建PCB
- **终止状态**
  - 操作系统回收进程的资源、撤销PCB

### 进程间状态切换

~~~ c
创建态 --> 就绪态 <---> 运行态 --> 终止态
    		^		   /
    		 \		  /
    		  \		 <
    		    阻塞态
~~~

- **就绪态 -> 运行态**
  - 进程被调度
- **运行态 -> 就绪态**
  - 时间片到，或CPU被其他更高优先级的进程抢占
- **运行态 -> 阻塞态**
  - 运行态的进程主动进入就绪态，等待系统分配资源，或等待某事件发生(主动行为)
- **阻塞态 -> 就绪态**
  - 资源分配完成，阻塞态的进程自动进入就绪态，等待事件发生(被动行为)
- **创建态 -> 就绪态**
  - 系统完成创建进程相关的工作
- **运行态 -> 终止态**
  - 进程运行结束，或运行过程中遇到不可修复的错误

## 进程控制

### 概念

- 进程控制就是要实现进程状态的切换
- 进程控制基于原语实现
  - 原语使用**关/开中断**来实现
  - 原语是一种特殊的程序
  - 原语的执行具有原子性

### 相关原语

- 进程的创建
- 进程的终止
- 进程的阻塞
- 进程的唤醒
- 进程的切换

## 进程通信

### 共享存储

- 设置一个共享空间
- 通信的进程互斥的访问共享空间
- 共享空间存储方式
  - 基于数据结构(低级) -- 数据类型、长度固定
  - 基于存储区的共享(高级) -- 数据类型、长度可变

### 管道通信

- 设置一个特殊的共享文件(管道)，实质为一个缓冲区
- 一个管道只能实现半双工通信
- 实现双向通信需要两个管道
- 各进程需要互斥访问管道
- 管道写满后不能再向管道写；管道读完后不能再从管道读
- 管道没写满时不能从管道读；管道没读完时不能向管道写
- 管道通信只能用于具有亲缘关系的进程之间(父子进程、兄弟进程)

### 消息传递

- 传递结构化的消息(消息头+消息体)
- 系统提供**发送**与**接收**的原语
- 消息传递方式
  - 直接通信方式 -- 消息直接挂载到接收方的消息队列里
  - 间接通信方式(信箱) -- 发送方将消息发送到信箱，接收方从信箱读取消息

## 线程

### 线程概念

- 线程可以理解为**轻量级进程**
- 线程可以增加并发度，减少并发带来的开销

### 线程机制优势

- 资源分配、调度粒度更细
- 并发性更好
- 系统开销更小(同一进程内的线程切换)

### 线程属性

- 线程是处理机调度的基本单位，进程是资源分配的基本单位
- 同一进程内的各线程共享进程的资源
- 同一进程内的各线程之间切换不会导致进程切换

### 实现方式

- **用户级线程**
  - 从用户视角看的线程
- **内核级线程**
  - 从操作系统视角看的线程 -- 内核线程才是处理机调度的基本单位
- **组合方式**
  - 用户级线程 + 内核级线程

### 多线程模型

- **多对一模型 **-- 多个用户即线程对应一个内核级线程
  - 优点：进程管理开销小，效率高
  - 缺点：一个线程阻塞会导致整个进程被阻塞 -- 并发度低
- **一对一模型** -- 一个用户级线程对应一个内核级线程 -- **Java多线程模型**
  - 优点：各个线程可分配到多核处理机并发执行，并发度高
  - 缺点：进程管理开销大
- **多对多模型** -- m个用户级线程对应n个内核级线程
  - 优点：集二者之所长
  - 缺点：实现复杂

## 处理机调度

### 概念

- 按某种算法选择一个进程将处理机分配给它

### 层次

- **高级调度** - 作业调度
  - 按某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建PCB
- **中级调度** - 内存调度
  - 按某种规则，从挂起队列中选择合适的进程将其数据调回内存
- **低级调度** - 进程调度
  - 按某种规则，从就绪队列中选择一个进程为其分配处理机

### 联系与对比

|                  | 高级调度                | 中级调度                              | 低级调度         |
| ---------------- | ----------------------- | ------------------------------------- | ---------------- |
| **调度范围**     | 外存 -> 内存 (面向作业) | 外存 -> 内存 (面向进程)               | 内存 -> CPU      |
| **发生频率**     | 最低                    | 中等                                  | 最高             |
| **进程状态影响** | 无 -> 创建态 -> 就绪态  | 挂起态 -> 就绪态 (阻塞挂起 -> 阻塞态) | 就绪态 -> 运行态 |

### 挂起

- 为减轻系统负载，提高资源利用率，暂时不执行的进程会被调到外存从而变为**挂起态**
- **七状态模型**：五状态模型的基础上加上**就绪挂起**和**阻塞挂起**两种状态

## 进程调度

### 时机

- **何时需要进程调度**
  - **主动放弃**
    - 进程正常终止
    - 运行过程中发生异常而终止
    - 主动阻塞(如 等待IO)
  - **被动放弃**
    - 时间片耗尽
    - 有更紧急的事情需要处理(如 IO中断)
    - 有更高优先级的进程进入就绪队列
- **何时不能进行进程调度**
  - 在**处理中断**的过程中
  - 进程在**操作系统内核程序临界区**中
  - **原子操作**过程中

### 切换

- **进程切换过程**
  - 对原来进程的各种状态信息的保存
  - 对新来进程的各种数据状态的恢复
- **进程的调度、切换是有代价的，并不是调度越频繁，并发度就越高**

### 方式

- **非剥夺调度方式** - **非抢占式**
  - 只能由当前运行的进程主动放弃CPU
- **剥夺调度方式** - **抢占式**
  - 可由操作系统剥夺当前进程的CPU使用权

## 调度算法评价指标

- **CPU利用率**	CPU忙碌时间 / 总时间
- **系统吞吐量** 	完成作业数量(道数) / 完成作业花费时间
- **周转时间**		作业完成时间 - 作业提交时间
  - **平均周转时间** 	各作业周转时间之和 / 作业数量
  - **带权周转时间** 	作业周转时间 / 作业实际运行的时间
  - **平均带权周转时间**	各作业带权周转时间之和 / 作业数
- **等待时间**		进程(作业)等待被服务的时间 (包括作业在外存后备队列中等待的时间 + 进程在就绪队列中等待的时间)
  - **平均等待时间**		各进程(作业)等待时间的平均值
- **响应时间**		从用户提交请求到首次产生响应所用的时间

## 调度算法一

 ### 先来先服务 - FCFS(First  Come First Service)

- **算法思想**
  - 先来先服务算法主要从**公平**角度考虑
- **算法规则**
  - 按照作业/进程到达的先后顺序进行服务
- **调度**
  - 用于作业调度时，考虑的是哪个作业先到达后备队列
  - 用于进程调度时，考虑的是哪个进程先到达就绪队列
- **是否可抢占**
  - 非抢占式的算法
- **特点**
  - 优点：公平、实现简单
  - 缺点：排在长作业/耗时进程后面的短作业需要等待很长时间，带权周转时间很大，对短作业用户来说体验不友好
  - **对长作业有利，对短作业不利**
- **是否导致饥饿** - 某进程或作业长期得不到服务
  -  不会

### 短作业优先 - SJF(Shortest  Job  First) / SPF(Shortest  project  First)

- **算法思想**

  - 追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间

- **算法规则**

  - 最短的作业/进程优先得到服务(最短是指要求服务的时间最短)

- **调度**

  - 既可用于作业调度也可用于进程调度

- **是否可抢占**

  - **SJF与SPF是非抢占式的算法**
  - **SRTN(Shortest Remaining Time Next)是抢占式的算法**，称为最短剩余时间优先算法

- **特点**

  - 优点：**“最短的”**平均等待时间与平均周转时间
  - 缺点：不公平，可能产生饥饿现象
  - **对短作业有利，对长作业不利**

- **是否导致饥饿**

  - **可能导致饥饿** - 如果源源不断的有短作业/进程到来，可能使长作业/进程一直得不到服务，产生饥饿现象；如果一直得不到服务，称为**进程饿死**


### 高响应比优先  - HRRN(Highest  Response  Ratio  Next)

- **算法思想**
  - 综合考虑作业/进程的等待时间和要求服务的时间
- **算法规则**
  - 在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务
  - **响应比  =  (等待时间 + 要求服务时间) / 要求服务时间**
- **调度**
  - 既可用于作业调度，也可用于进程调度
- **是否可抢占**
  - **非抢占式**
- **特点**
  - **综合考虑了等待时间和运行时间(要求服务时间)**
  - 等待时间相同时，要求服务时间短的优先被服务 - SJF的优点
  - 要求服务时间相同时，等待时间长的优先被服务 - FCFS的优点
  - 对于长作业来说，随着等待时间越来越久，其响应比也越来越高(优先级提高)，避免了长作业饥饿的情况
- **是否导致饥饿**
  - **不会导致饥饿** - 非抢占式

## 调度算法二

### 时间片轮转调度算法 - RR(Round  -  Robin)

- **算法思想**
  - 公平地、轮流地为各个进程服务，让每个进程在一定的时间间隔内都可以得到响应
- **算法规则**
  - 按照各个进程到达就绪队列的顺序，轮流的让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列中重新排队，等待时间片的分配
- **调度**
  - 用于**进程调度**(只有作业放入内存建立了相应的进程后，才能被分配处理机资源)
- **是否可抢占**
  - 若进程未能在时间片内运行完，将被强行剥夺处理机使用权。因此，时间片轮转调度算法属于**抢占式**的算法。**由时钟装置发出时钟中断来通知CPU时间片已到**
- **特点**
  - 优点：公平、响应快，适用于分时系统
  - 缺点：由于高频率的进程切换，因此会有一定的进程却换的开销；不区分任务的紧急程度
- **是否导致饥饿**
  - **不会导致饥饿**
- **时间片大小设置**
  - 时间片设置太大，会使算法退化为FCFS，进程的响应时间长
  - 时间片设置太小，进程切换的频率过高，开销增大

### 优先级调度算法

- **算法思想**
  - 根据任务的紧急程度来决定处理顺序
- **算法规则**
  - 调度时选择优先级最高的作业/进程
- **调度**
  - 既可用于作业调度也可用于进程调度，还可用于I/O调度
- **是否可抢占**
  - **抢占式与非抢占式都可**
    - 非抢占式只需在进程主动放弃处理机资源时进行调度即可
    - 抢占式需要在就绪队列变化时检查是否会发生抢占
- **特点**
  - 优点：用优先级取分紧急程度、重要程度，适用于实时操作系统，可灵活地调整对各作业/进程的偏好程度
  - 缺点：若源源不断的有高优先级的进程到达，可能导致饥饿现象
- **是否导致饥饿**
  - **可能导致饥饿** - 源源不断的有高优先级的进程到达

### 多级反馈队列调度算法

- **算法思想**
  - 对其他调度算法的折中权衡
- **算法规则**
  - 设置多级队列，各级队列按优先级从高到低，时间片从小到大
  - 新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程放入下一级队列的队尾
  - 只有第k级队列为空时，才会为k + 1级队列对头的进程分配时间片
- **调度**
  - 用于**进程调度**
- **是否可抢占**
  - **抢占式的算法**
  - 在k级队列的进程的运行过程中，若更上级的队列(1 ~ k - 1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾
- **特点**
  - 对各类型的进程相对公平(FCFS)
  - 每个新到达的进程都会很快得到响应(RR的优点)
  - 短进程只用较少的时间就可以完成(SPF的优点)
  - 不必实现估计进程的运行时间(避免用户作假)
  - 可灵活的调整对各进程的偏好程度，比如CPU密集型进程、I/O密集型进程(可以将因I/O而阻塞的进程重新放回原队列，从而使I/O进程保持较高优先级)
- **是否导致饥饿**
  - **可能导致饥饿** - 源源不断的有进程到达

## 进程同步与进程互斥

### 进程同步

- 并发性带来了异步性，有时候需要通过进程同步来解决异步问题
- 有的进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的先后顺序

### 进程互斥

- 对临界资源的访问，需要互斥的进行。即同一时间段内只能允许一个进程访问该资源
- **四个部分**
  - **进入区**：检查是否可以进入临界区，若可以进入，则需要**加锁**
  - **临界区**：访问临界资源的代码段
  - **退出区**：负责**解锁**
  - **剩余区**：其余代码段
- **原则**
  - **空闲让进**：临界区空闲时，应允许一个进程访问
  - **忙则等待**：临界区正在被访问时，其他试图访问的进程需要等待
  - **有限等待**：要在有限的时间内进入临界区，保证不会饥饿
  - **让权等待**：进入不了临界区的进程，需要释放处理机，防止忙等

## 进程互斥 - 软件实现

### 单标志法

- **算法思想**

  - 两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。即**每个进程进入临界区的权限只能被另一个进程赋予**

  ~~~ c
  int trun = 0;	// turn 表示当前允许进入临界区的进程号
  // P0进程
  while (turn != 0);	// 进入区
  critical section;   // 临界区
  turn = 1;		   // 退出区
  remainder section;  // 剩余区
  
  // P1进程
  while (turn != 1);	// 进入区
  critical section;   // 临界区
  turn = 0;		   // 退出区
  remainder section;  // 剩余区
  ~~~

- **特点**
  - 在进入区只做“检查”，不“上锁”
  - 在退出区把临界区的使用权转交给另一个进程(相当于在退出区既给另一进程“解锁”，又给自己"上锁")
  - 主要问题：不遵循**空闲让进**原则

### 双标志先检查法

- **算法思想**

  - 设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿。每个进程在进入临界区之前先检查当前是否有别的进程想进入临界区，如果没有，则将自身对应的标志位flag[i]设置为true，之后开始访问临界区

    ~~~ c
    bool flag[2];		// 表示进入临界区意愿的数组
    flag[0] = false;
    flag[1] = false;	// 初始时设置为两个进程都不想进入临界区
    //P0进程
    while (flag[1]);	// 若此时P1有意愿进入临界区，则P0需要等待
    flag[0] = true;		// 标记为P0想进入临界区
    critical section;	// 访问临界区
    flag[0] = false;	// 访问结束，修改标记为P0不想进入临界区
    remainder section;	// 剩余区
    
    //P1进程
    while (flag[0]);	// 若此时P0有意愿进入临界区，则P1需要等待
    flag[1] = true;		// 标记为P1想进入临界区
    critical section;	// 访问临界区
    flag[1] = false;	// 访问结束，修改标记为P1不想进入临界区
    remainder section;	// 剩余区
    ~~~

- **特点**

  - 在进入区先“检查”，再“上锁”，再退出区“解锁”
  - 主要问题：不遵循**忙则等待**原则 - 多进程同步问题

### 双标志后检查

- **算法思想**

  - 双标志先检查的改版，使用先“上锁”，后“检查”的机制

    ~~~ c
    bool flag[2];		// 表示进入临界区意愿的数组
    flag[0] = false;
    flag[1] = false;	// 初始时设置为两个进程都不想进入临界区
    //P0进程
    flag[0] = true;		// 标记为P0想进入临界区
    while (flag[1]);	// 若此时P1有意愿进入临界区，则P0需要等待
    critical section;	// 访问临界区
    flag[0] = false;	// 访问结束，修改标记为P0不想进入临界区
    remainder section;	// 剩余区
    
    //P1进程
    flag[1] = true;		// 标记为P1想进入临界区
    while (flag[0]);	// 若此时P0有意愿进入临界区，则P1需要等待
    critical section;	// 访问临界区
    flag[1] = false;	// 访问结束，修改标记为P1不想进入临界区
    remainder section;	// 剩余区
    ~~~

- **特点**

  - 在进入区先“上锁”，后“检查”，退出区“解锁”
  - 主要问题：不遵循**空闲让进**、**有限等待**原则，可能导致饥饿 - 多进程同步问题

### Peterson算法

- **算法思想**

  - 如果双方都争着想进入临界区，则让进程尝试谦让，主动让对方先使用临界区

    ~~~ c
    bool flag[2];	// 表示想进入临界区意愿的数组，初始值都是false
    int turn = 0;	// turn 表示优先让哪个进程进入临界区
    // P0进程
    flag[0] = true;				 // 表示自己想进入临界区
    turn = 1;					// 可以优先让对方进入临界区
    while(flag[1] && turn == 1);  // 对方想进入临界区，且最后一次发出谦让的是自己(设置turn)，则自己等待
    critical section;
    flag[0] = false;			 // 访问完临界区，表示自己已经不想访问临界区了
    remainder section;
    
    // P1进程
    flag[1] = true;				 // 表示自己想进入临界区
    turn = 0;					// 可以优先让对方进入临界区
    while(flag[0] && turn == 0);  // 对方想进入临界区，且最后一次发出谦让的是自己(设置turn)，则自己等待
    critical section;
    flag[1] = false;			 // 访问完临界区，表示自己已经不想访问临界区了
    remainder section;
    ~~~

- **特点**

  - 在进入区**主动争取 - 主动谦让 - 检查对方是否想进、己方是否谦让**
  - 主要问题：不遵循**让权等待**原则，会发生忙等

## 进程互斥 - 硬件实现

## 中断屏蔽方法

- 使用**开/关中断**指令实现
- **特点**
  - 优点：简单高效
  - 缺点：只适用于单处理机、只适用于操作系统内核程序(中断指令是内核级指令，若交给用户程序随意使用会很危险)

### TestAndSet - TS指令/TSL指令

- **TSL指令使用硬件实现的，执行的过程中不允许被中断，具有原子性**

  ~~~ c
  // TSL指令逻辑描述
  // 布尔型共享变量 lock 表示当前临界区是否被加锁
  // true表示已加锁， false表示未加锁
  bool TestAndSet(bool *lock) {
      bool old;
      old = *lock;	// old字段用来存放lock原来的值
      *lock = true;	// 无论之前是否加锁，都将lock设置为true
      return old;		// 返回原来的lock的值
  }
  
  // 使用TSL指令实现互斥的算法逻辑
  while (TestAndSet(&lock));	//"加锁"并"检查"
  // 临界区代码段...
  lock = false;	// "解锁"
  // 剩余区代码段...
  ~~~

- **特点**

  - 优点：实现简单、适用于多处理机环境
  - 缺点：不满足**让权等待**

### Swap指令 - XCHG指令

- **Swap指令使用硬件实现的，执行的过程中不允许被中断，具有原子性**

  ~~~ c
  // Swap指令逻辑描述
  // Swap指令的作用是交换两个变量的值
  Swap(bool *a, bool *b) {
      bool tmp;
      tmp = *a;
      *a = *b;
      *b = tmp;
  }
  
  // 使用Swap指令实现互斥的算法逻辑
  // lock 表示当前临界区是否被加锁
  bool old = true;
  while (old = true)
      Swap(&lock, &old);
  // 临界区代码段...
  lock = false;
  // 剩余区代码段...
  ~~~

- **特点** - 同TSL指令

## 信号量机制

### 整型信号量

- **实现思路**

  - 用一个**整数型变量**作为**信号量**，用来表示**操作系统中某种资源的数量**

    ~~~ c
    // Eg.某计算机中有一台打印机
    int S = 1;	// 初始化整型信号量S，表示当前系统中可用的打印机资源数
    
    void wait(int S) {	// wait原语，相当于"进入区"
        while (S <= 0);	// 如果资源数不够，就一直循环等待
        S--;		   // 如果资源数够，则占用一个资源
    }
    
    void signal(int S) { // signal原语，相当于"退出区"
        S++;			// 使用完资源后，在退出区释放资源
    }
    
    // 进程P0
    // ...
    wait(S);			 // 进入区，申请资源
    // 使用打印机资源...	// 临界区，访问资源
    signal(S);			 // 退出区，释放资源
    // ...
    
    // 进程P1
    // ...
    wait(S);			 // 进入区，申请资源
    // 使用打印机资源...	// 临界区，访问资源
    signal(S);			 // 退出区，释放资源
    // ...
    
    // ...
    ~~~

- **特点**

  - 整型信号量与普通整型变量的区别：**对信号量只能执行 初始化、P、V 三种操作，且都是原子性操作**
  - 问题：不能满足**让权等待**规则

### 记录型信号量

- **实现思路**

  - 用**记录型数据结构**表示**信号量**

    ~~~ c
    // 记录型信号量的定义
    typedef struct {
        int value;			// 剩余资源数
        struct process *L;	 // 等待队列
    } Semaphore;
    
    // 某进程需要使用资源时，通过 wait 原语申请
    void wait(Semaphore S) {
        S.value--;
        if (S.value < 0) {
            // 如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并将其添加到信号量S的等待队列中
            block(S.L);
        }
    }
    
    // 某进程使用完资源后，通过 sgnial 原语释放
    void signal(Semaphore S) {
        S.value++;
        if (S.value <= 0) {
            // 释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
            wakeup(S.L);
        }
    }
    ~~~

- **特点**

  - 可以用记录型信号量实现系统资源的“申请”和“释放”
  - 可以用记录型信号量实现进程互斥、进程同步

## 信号量应用

### 实现进程互斥

- 分析问题，确定临界区
- 设置互斥信号量，**初始值为1**
- 临界区之前对信号量执行 P 操作
- 临界区之后对信号量执行 V 操作

### 实现进程同步

- 分析问题，找出哪里需要实现**一前一后**的同步关系
- 设置同步信号量，**初始值为0**
- 在前一个进程操作完成后对信号量执行 V 操作
- 在后一个进程操作开始前对信号量执行 P 操作

### 实现进程的前驱关系

- 分析问题，画出前驱图，每一对前驱关系都对应一个同步问题
- 为每一对前驱关系设置信号量，**初始值为0**
- 在前一个进程操作完成后对信号量执行 V 操作
- 在后一个进程操作开始前对信号量执行 P 操作

## 生产者-消费者 模型

### 实现方案

- 生产者、消费者共享一个**初始为空、大小为n的缓冲区**

- 只有**缓冲区没满**时，生产者才能将产品放入缓冲区，否则必须等待

- 只有**缓冲区装满**时，消费者才能从缓冲区去除产品，否则必须等待

- 缓冲区是临界资源，各进程必须**互斥地访问**

  ~~~ c
  semaphore mutex = 1;	// 互斥信号量，实现对缓冲区的互斥访问
  semaphore empty = n;	// 同步信号量，表示空闲缓冲区的数量
  semaphore full = 0;		// 同步信号量，表示非空闲缓冲区的数量(产品的数量)
  
  // 生产者
  void producer() {
      while(1) {
          // 生产一个产品
          P(empty);	// 消耗一个空闲缓冲区
          P(mutex);	// 实现进程的互斥访问
          // 将产品放入缓冲区
          V(mutex);
          V(full);	// 释放一个非空闲缓冲区(增加了一个产品)
      }
  }
  
  // 消费者
  void customer() {
      while(1) {
          // 消耗一个产品
          P(full);	// 消耗一个非空闲缓冲区
          P(mutex);	// 实现进程的互斥访问
          // 从缓冲区取出产品
          V(mutex);
          V(empty);	// 释放一个空闲缓冲区
      }
  }
  ~~~

- **特点**

  - **进程同步**：消费者 - 生产者，生产者 - 消费者
  - **消费者与生产者互为前驱进程，有两组同步关系，因此需要两个同步信号量 empty 与 full**
  - **进程互斥**：消费者 - 消费者，生产者 - 生产者， 消费者 - 生产者
  - **进程互斥使用 mutex 信号量实现**

- **互斥与同步**
  - **实现互斥的操作要放在实现同步的操作后面**
    - 若先 P(mutex) ，后 P(empty)，则可能导致生产者进程在上锁之后，却发现无法向缓冲区添加产品(缓冲区已满)；而若此时消费者进程想要消费产品，却会在 P(mutex) 处阻塞，导致生产者无法添加，而消费者也无法消费的状态 -- **死锁**
  - **ps**：原则上，可以将生产产品与消耗产品的代码段放到 P(empty / full) 之后，逻辑上没有问题，但这样做会使得同步块内的代码段增大，处理逻辑增多，从而降低并发度

## 多生产者 - 多消费者 模型

### 问题分析

- 桌子上有一只盘子，每次只能向盘子中放一个水果。父亲专向盘子里放苹果，母亲专向盘子里放橘子；儿子专等着吃盘子里的橘子，女儿专等着吃盘子里的苹果。只有盘子为空时，父亲或母亲才可以向盘子里放入水果。仅当盘子里有自己想吃的水果时，儿子或女儿才能从盘子里取水果。

~~~ c
			apple=0  
父亲 V 	   ------> 		P 女儿
    <					>
      \		plate=1	   /
    	---------------
      /		   		   \
    <					>
母亲 V 	   ------> 		P 儿子
         	orange=0
~~~

- **互斥关系**
  - 对缓冲区(盘子)的访问要互斥的进行
- **同步关系**
  - 父亲将苹果放入盘子后，女儿才能取苹果
  - 母亲将橘子放入盘子后，儿子才能取橘子
  - **只有盘子为空时，父亲或母亲才能放入水果**

### 实现方案

~~~ c
semaphore mutex = 1;	// 实现互斥访问盘子(缓冲区)
semaphore apple = 0;	// 盘中有几个苹果
semaphore orange = 0;	// 盘中有几个橘子
semaphore plate = 1;	// 盘中还可以放多少个水果

// 父亲
void dad() {
    while (1) {
        // 准备一个苹果
        P(plate);
        P(mutex);
        // 把苹果放入盘子
        V(mutex);
        V(apple);
    }
}

// 母亲
void mon() {
    while (1) {
        // 准备一个橘子
        P(plate);
        P(mutex);
        // 把橘子放入盘子
        V(mutex);
        V(orange);
    }
}

// 儿子
void son() {
    while (1) {
        P(orange);
        P(mutex);
        // 从盘中取出橘子
        V(mutex);
        V(plate);
        // 吃掉橘子
    }
}

// 女儿
void daughter() {
    while (1) {
        P(apple);
        P(mutex);
        // 从盘中取出苹果
        V(mutex);
        V(plate)
    }
}
~~~

- **若盘子中只允许放一个水果，则在同一时刻`apple`、`orange`、`plate`三者中只会有一个的值为1，此时不需要`mutex`来进行互斥**
- **若盘子中允许放多个水果，则需要`mutex`信号量来进行互斥，否则可能发生数据覆盖的问题 -> 父亲与母亲同时向盘子中放水果，父亲先放完，母亲再放到同一个位置，造成父亲的数据被母亲的覆盖**

## 吸烟者问题

### 问题分析

- 假设一个系统有**三个吸烟者进程**和**一个供应者进程**。每个抽烟者不停地卷烟并抽掉，但是要卷烟并抽掉一支烟，抽烟者需要三种材料：**烟草、纸和胶水**。三个抽烟者中，**第一个拥有烟草，第二个拥有烟纸，第三个拥有胶水**。供应者进程无限地提供三种材料，供应者每次将两种材料放在桌上，**拥有剩下一种材料的抽烟者就可以卷一根烟并抽掉它，并给供应者一个信号告诉抽烟完成了**，供应者收到信号后就会放另外两种材料在桌上，这个过程一直重复(让三个抽烟者轮流的抽烟)
- **抽烟者**
  - 抽烟者一：持有烟草
  - 抽烟者二：持有纸
  - 抽烟者三：持有胶水
- **材料组合**
  - 组合一：纸 + 胶水
  - 组合二：烟草 + 胶水
  - 组合三：烟草 + 纸
- **互斥关系**
  - 桌子可以抽象为容量为1的缓冲区，各进程需要互斥访问
- **同步关系**
  - 桌上有组合一  -->  第一个抽烟者取走东西
  - 桌上有组合二  -->  第二个抽烟者取走东西
  - 桌上有组合三  -->  第三个抽烟者取走东西
  - 发出完成信号  -->  供应者将下一个组合放到桌上

### 实现方案

~~~ c
// 供应者
void provider() {
    while (1) {
        if (i == 0) {
            // 将组合一放到桌上
            V(offer1);
        }
        else if (i == 1) {
            // 将组合二放到桌上
            V(offer2);
        }
        else if (i == 2) {
            // 将组合三放到桌上
            V(offer3);
        }
        i = (i + 1) % 3;
        P(finish);
    }
}

// 同步变量
semaphore offer1 = 0;	// 桌上组合一的数量
semaphore offer2 = 0;	// 桌上组合二的数量
semaphore offer3 = 0;	// 桌上组合三的数量
semaphore finish = 0;	// 抽烟是否完成
int i = 0; 			   // 用于实现"三个抽烟者轮流抽烟"

// 第一个抽烟者
void smokeOne() {
    while (1) {
        P(offer1);
        // 从桌上拿走组合一；卷烟；抽掉
        V(finish);
    }
}

// 第二个抽烟者
void smokeTwo() {
    while (1) {
        P(offer2);
        // 从桌上拿走组合二；卷烟；抽掉
        V(finish);
    }
}

// 第三个抽烟者
void smokeThree() {
    while (1) {
        P(offer3);
        // 从桌上拿走组合三；卷烟；抽掉
        V(finish);
    }
}
~~~

- **若桌子只有一个，即缓冲区的大小为1，则在同一时刻，四个信号量`offer1`、`offer2`、`offer3`、`finish`中只会有一个的值为1，其他为0，因此，可以不用设置`mutex`信号量来互斥**
- **若桌子不只一个，则需要`mutex`信号量来帮助实现互斥**

## 读者 - 写者问题

### 问题分析

- 有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某一个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求：
  - **允许多个读者可以同时对文件进行读操作**
  - **只允许一个写者往文件中写信息**
  - **任一写者在完成写操作之前不允许其他读者或写者工作**
  - **写者执行写操作前，应让已有的读者和写者全部退出**
- **互斥关系**
  - 写进程 - 写进程
  - 写进程 - 读进程
  - 写进程与任何进程都要互斥，设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作。
  - 读进程与写进程也要互斥，在读者访问共享文件前后也要分别执行P、V操作
- **问题**
  - 如果所有的读进程在访问共享文件前都执行P(rw)操作，那么会导致各个读进程之间也无法同时访问文件。
- **解决方案**
  - **P(rw)和V(rw)就是对共享文件的加锁和解锁**。既然各个读进程需要同时访问，而读进程与写进程之间又需要互斥访问，可以**让第一个访问文件的读进程加锁，让最后一个访问完文件的读进程解锁**。可以通过设置一个整数变量count来记录当前有几个读进程正在访问文件

### 实现方案

~~~ c
semaphore rw = 1;		// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件
int count = 0;			// 记录当前访问共享文件的读进程的数量
semaphore mutex = 1;	// 用于保证对count变量的互斥访问

// 写者
void writer() {
    while (1) {
        P(rw);	// 写之前加锁
        // 写文件
        V(rw);	// 写之后解锁
    }
}

// 读者
void reader() {
    while (1) {
        P(mutex);	// 各读进程需要互斥地访问count
        if (count == 0)
            P(rw);	// 第一个读进程负责加锁
        count++;	// 访问的读进程数加一
        V(mutex);
        // 读文件
        P(mutex);	// 各读进程互斥地访问count
        count--;	// 访问完后
        if (count == 0)
            V(rw)	// 最后一个读进程解锁
        V(mutex);
    }
}
~~~

## 哲学家进餐问题

### 问题分析

- 一张圆桌上坐着5个哲学家，每两个哲学家之间摆放着一只筷子，桌子中间是食物。**哲学家只能做思考和进餐两件事情**。哲学家在思考时不会影响他人，只有当哲学家饥饿时，才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已经在别的哲学家手上，则当前哲学家需要等待。饥饿的哲学家只有同时拿起两根筷子才可以进餐，当进餐完毕后，放下筷子继续思考

  ~~~ c
  			 2
  			 A
      3  \			/ 2       
  3 B						E 1
             	 食物   
       4 /           	  \ 1
                  
  	4 C		 |		D 0
                0
  ~~~

- **关系分析**

  - **互斥关系**：系统中有5个哲学家进程(A、B、C、D、E)，5个哲学家与左右邻居对中间筷子的访问时互斥关系
  - **整理思路**：该问题中只有互斥关系，但每个哲学家进程需要同时持有两个资源才能进行工作。**如何避免临界资源分配不当造成死锁现象**是哲学家问题需要考虑的关键
  - **信号量设置**：定义互斥信号量数组`chopstick[5] = {1, 1, 1, 1, 1}`用于实现对5个筷子的互斥访问

### 死锁解决方案

- **方案一**：可以对哲学家进程施加一些限制条件，如最多只允许4个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的

- **方案二**：要求奇数号的哲学家先拿左边的筷子，然后再拿右边的筷子，偶数号的哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想进餐，则只会有其中一个可以拿起第一只筷子，另一个就会阻塞。这样就避免了占有一只筷子后再等待另一只的情况

- **方案三**：仅当一个哲学家的左右两只筷子都可以使用时才允许他抓起筷子

  ~~~ c
  semaphore chopstick[2] = {1, 1, 1, 1, 1};
  semaphore mutex = 1;		 // 互斥地取筷子
  void pi() {					// 第i号哲学家
      P(mutex);
      P(chopstick[i]);		 // 拿左边的筷子
      P(chopstick[(i + 1) % 5]);// 拿右边的筷子
      V(mutex);
      // 进餐
      V(chopstick[i]);		 // 放下左边的筷子
      V(chopstick[(i + 1) % 5]);// 放下右边的筷子
  }
  ~~~

## 管程

### 由来

- 为解决信号量机制变成麻烦、易出错的问题，引入管程

### 组成

- 共享数据结构
- 对数据结构初始化的语句
- 一组用来访问数据结构的过程(函数)

### 基本特征

- 各外部进程/线程只能通过管程提供的特定入口(方法)才能访问共享数据
- 每次仅允许一个进程在管程内执行某个内部程序

### 补充

- 各进程必须互斥地访问管程的特性是由编译器实现的，程序员不需要关注
- 可在管程中设置条件变量及等待/唤醒操作以解决同步问题

## 死锁

### 概念

- 在并发环境下，各进程因竞争资源而造成的一种**互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进**的现象
- 发生死锁后若无外力干涉，这些进程都将无法向前推进

### 死锁、饥饿、死循环

- **死锁**
  - **概念**：各进程相互等待对方手里的资源，导致各进程都阻塞，无法向前推进
  - 死锁一定是**循环等待对方手里的资源**导致的，因此，**如果发生死锁，那么至少有两个或两个以上的进程同时发生死锁**
  - **发生死锁的进程一定处于阻塞状态**
- **饥饿**
  - **概念**：某进程由于长期得不到想要的资源，无法向前推进
  - **可能只有一个进程发生饥饿**
  - **发生饥饿的进程可能处于阻塞态，也可能处于就绪态**
- **死循环**
  - **概念**：某进程执行过程中一直跳不出某个循环。有时是因为程序bug造成的，有时是程序员故意设计的
  - **可能只有一个进程发生死循环**
  - 死循环的进程可以上处理机运行(**可以是运行态**)
  - 死锁和饥饿现象是由操作系统分配资源不合理导致的，而死循环是由代码逻辑的错误导致的
  - 死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者的问题

### 死锁条件

- **互斥条件**
  - 只有对必须互斥使用的资源进行争抢时才会导致死锁
  - 像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的
- **不可剥夺条件**
  - 进程所获得的资源在未使用完前**不能由其他进程强行夺走**，只能主动释放
- **请求和保持条件**
  - 进程**已经保持了至少一个资源**，但又对新的资源提出请求，而该资源又被其他进程锁占有，此时请求进程被阻塞，但又对自己已有的资源保持不释放
- **循环等待条件**
  - 存在一种**进程资源的循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求
- **注意**：发生死锁时一定有循环等待，但发生循环等待时未必会死锁
  - 如果同类资源的数量大于1，则即使有循环等待，也未必会发生死锁
  - 如果系统中每种资源的数量都只有一个，那么循环等待就是死锁的充分必要条件

### 死锁发生

- **对系统资源的竞争**

  - 各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的

- **进程推进顺序非法**

  - 请求和释放资源的顺序不当，会导致死锁

- **信号量使用不当**

  - 如生产者 - 消费者问题中，若实现互斥的P操作在实现同步的P操作之前，则可能导致死锁

  **总之，对不可剥夺的资源的不合理分配，可能导致死锁**

### 处理策略

- **预防死锁**
  - 破坏死锁产生的四个必要条件中的一个或多个
- **避免死锁**
  - 用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)
- **死锁的检测和解除**
  - 允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施接触死锁

## 预防死锁

### 破坏互斥条件

- **将临界资源改造为可以共享使用的资源**。如：**SPOOLing技术**，操作系统可以通过SPOOLing技术将独占设备在逻辑上改造成共享设备
- **缺点**
  - 可行性不高
  - 并且为了系统安全，很多地方需要保证资源的互斥性，因此，**很多时候都无法破坏互斥条件**

### 破坏不可剥夺条件

- **方案一**：申请的资源得不到满足时，立刻释放拥有的所有资源
- **方案二**：申请的资源被其他进程占用时，由操作系统协助剥夺(考虑优先级)
- **缺点**
  - 实现复杂
  - 剥夺资源可能导致部分工作失效
  - 反复申请和释放导致系统开销大
  - 可能导致饥饿

### 破坏请求与保持条件

- **运行前分配好所有需要的资源，之后一直保持**
- **缺点**
  - 资源利用率低
  - 可能导致饥饿

### 破坏循环等待条件

- **给资源编号，必须按照编号从小到大的顺序申请资源**
- **缺点**
  - 不方便增添新设备
  - 会导致资源浪费
  - 用户编程麻烦

## 避免死锁

### 银行家算法

- 在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待

  ~~~ c
  // P - 进程的集合
  // Mp - 进程p的最大的请求数目
  // Cp - 进程p当前被分配的资源
  // A - 当前可用的资源
  
  while (P != ∅) {
      found = false;
      foreach (p ∈ P) {
          if (Mp − Cp ≤ A) {
               // p可以获得他所需的资源。假设它得到资源后执行；执行终止，释放所有的资源
               A = A + Cp ;
               P = P − {p};
               found = true;
          }
      }
      if (! found) return FAIL;
  }
  return OK;
  ~~~

## 死锁的检测和接触

### 死锁检测

- **数据结构**：**资源分配图**
  - **两种节点**
    - **进程节点**
    - **资源节点**
  - **两种边**：
    - **进程节点 -> 资源节点 - 请求边**
    - **资源节点 -> 进程节点 - 分配边**
- **死锁检测算法**
  - **依次消除与不阻塞进程相连的边，直到无边可消**(不阻塞进程：指其申请的资源数还足够的进程)
  - **死锁定理**：**若资源分配图是不可完全简化的，说明发生了死锁**

### 死锁解除

- **资源剥夺法**
  - 挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿
- **撤销进程法**
  - 强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源
  - **特点**
    - 优点：实现简单
    - 缺点：代价可能很大：因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止还需要从头再来执行
- **进程回退法**
  - 让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统记录进程的历史信息，设置还原点
- **进程选择**
  - 选择对哪个或哪些进程进行**挂起、撤销、回退**操作，可按照以下方案
    - **进程优先级**
    - **已执行时间**
    - **还需执行时间**
    - **进程已经使用了多少资源**
    - **进程是交互式还是批处理式** - 优先交互式(满足用户体验)
